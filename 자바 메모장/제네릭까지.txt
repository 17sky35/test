1. 자료형
자료형     키워드        크기        표현범위
논리형    boolean       1bit        true,false
문자형    char           2byte       0
정수형    byte           1byte	      -128 ~ 17
	short	    2byte       -32,768 ~ 32,767	
	int	    4byte       -21억 ~ 21억
	long	    8byte	      -900경 ~ 900경
실수형   	float	    4byte       0.0
	double       8byte       0.0



연산자(Operator)
최고연산자	.   ,   ()
증감연산자	++,--
산술연산자	+,-,*,/,%
시프트연산자	>>,<<
비교연산자	>,<,>=,<=,==,!=
논리연산자	&&,||,!
비트연산자	&,|,~,^
대입연산자	=,+=,-=,*=,/=,%=
삼항연산자	조건식 ? A : B

-------------------------------------------
String 를 int 로 변환할때		ㅣ
Integer.parseInt("정수형태의 문자열");	ㅣ
-------------------------------------------

--------입력 받기----------------------------------------------------------------------------
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));	ㅣ
String str = br.readLine();   <-  str 문자열 입력받을때				ㅣ
System.out.print("정수 입력 : ");						ㅣ
int n = Integer.parseInt(br.readLine());						ㅣ
----------------------------------------------------------------------------------------------



Object 	자바 클래스의 최상위 클래스
System 	시스템의 표준 입력/출력 장치로부터 데이터를 입력받거나 출력하기 위해 사용
String 	문자열을 저장하고 여러 가지 정보를 얻을 때 사용
StringBuffer/StrngBuilder 	문자열을 저장하고 내부 문자열을 조작할 때 사용
Math 	수학관련 함수를 이용할 때 사용


hashCode();	주소값을 볼 수 있는 메서드
toString()		객체 자신의 정보를 볼 수 있는 메서드
str1.equals(str2)			문자열 값 비교
System.identityHashCode(문자열) 	문자열 위치(주소) 출력

str.length() str 의 길이
str.indexOf('a') str 문자열에서 a의 인덱스 위치 맨앞쪽 1개 위치만 출력
str.indexOf("Kin") 문자열 검색도 가능
str.lastIndexOf('n') str 문자열에서 n의 인덱스 위치 맨뒤쪽 1개 위치만 출력
str.charAt(4) str 문자열에서 인덱스4번 호출
str.substring(0,6) str 문자열에서 인덱스 0번부터 5번까지 출력
Arrays.toString(str.split(" ")) syt문자열에서 " " 기준으로 잘라내서 배열에 저장


str.append(String str) 		기존 문자열 뒤에 더하여 반환
str.delete(int start, int end) 		시작 위치부터 끝 위치 전까지 삭제
str.insert(int offset, String str) 	시작 위치부터 문자열을 삽입
str.reverse()			문자열을 반대로 출력
str.replace("Mal","Gae")		Mal을 Gae로 바꾼다
str.contains(String str)		특정문자를 포함하고 있는지 판별
str.isEmpty()			길이가 0인경우 true


날짜 시간 클래스 calendar
Calendar cal = Calendar.getInstance();
Calendar클래스의 속성
YEAR,MONTH,DATE 	연,월(0-11),일(1-31)을 나타내는 상수
DAY_OF_MONTH 		현재 달을 몇 번쨰 날인지는 나타내는 상수
DAY_OF_WEEK 		현재 주의 몇번째 요일인지 나타내는 상수(1-7),1이 일요일
HOUR,MINUTE 		시, 분을 나타내는 상수
SECOND, MILLISECOND 	초, 밀리초를 나타내는 상수
HOUR_OF_DAY 		현재 날의 시각을 의미하는 상수
AM_PM HOUR		가 정오보다 이전이면 0을, 이후이면 의 값을 가지는 상수
WEEK_OF_MONTH		현재 달의 몇 번쨰 주인지를 나타내는 상수
WEEK_OF_YEAR 		현재 해의 몇 번쨰 주인지를 나타내는 상수

int year = cal.get(Calendar.YEAR);
int month = cal.get(Calendar.MONTH)+1;
int day = cal.get(Calendar.DAY_OF_MONTH);


타입 파라미터 기호 네이밍
<T>	타입(TYPE)
<E>	요소(Element)
<K> 	키(Key)
<V>	값(Value)
<N> 	숫자<Number>

---------------------------------------------------------------------------------
Iterator<Integer> iter = set4.iterator();
hasNext() -> 다음에 순회할 요소가 있으면 true,아니면 false
while(iter.hasNext()) {
	//다음 요소를 반환한다.
	int val = iter.next();
	System.out.println(val);
}

List에서 제공하는 주요 메서드

void add(E e)		삽입	데이터를 순차적으로 삽입
void add(int index, E e)	중간삽입	원하는 index 위치에 삽입
void set(int index,E e)	치환	원하는 index 위치에 값 변경
E get(int index)		반환	선택된 index 위치의 값 반환
remove(int index)		삭제 	선택된 index 위치의 값 삭제
removeAll(Collection c)	삭제	삭제하고 true,false
clear()			전체삭제 모든 데이터 삭제
size()			크기 	저장된 데이터의 개수 반환
contains(Object o)	검색 	데이터 존재 여부 확인
Collections.shuffle(list);	섞기	list 배열 무작위로 섞기

List
- 요소를 계속 넣을수 있다
- index가 존재한다
- 중복된 데이터 허용

Map
Map<Integer, Character> map = new HashMap<Integer, Character>();  -> Integer -> key
put(Integer, Character)	추가
remove(Integer)		삭제	반환가능
size(Integer)		크기
get(Integer)		반환
containsKey("k3")		map에 특정 key("k3")값이 포함되어있는지 확인하는 메서드
containsValue()		map에 특정 Value 값이 포함되어있는지 확인하는 메서드


Set인터페이스에서 제공하는 메서드
HashSet
- 중복허용 X
- 순서대로 저장된다는 보장이 없음
void add(E e)		데이터를 순차적으로 삽입
void remove(Object o)	선택된 값 삭제
void clear()		모든 데이터 삭제
size()			저장된 데이터의 개수 반환
contains(Object o)	데이터 존재 여부 확인


TreeSet
TreeSet<Integer> set = new TreeSet<>();
TreeSet<Integer> set = new TreeSet<>(Arrays.asList(1,2,3));
set.first()		최소값을 찾아서 반환
set.last()		최대값을 찾아서 반환
set.higher(7)	인자로 전달된 값보다 바로 큰 데이터중 최소값 출력 없으면 null
set.lower(7)	인자로 전달된 값보다 바보 작은 데이터중 최소값 출력 없으면 null



Iterator 메서드
반복자
List<String> list = new ArrayList<>();
Iterator<Integer> iter = list.iterator();
boolean hasNext()		다음에 순회할 데이터 유무확인
			가져올 객체가 있으면 true
E nest()			다음 위치의 데이터로 이동하여 반환


---------------------------------------------------------------------------------

int n = 100;
int - 자료형
n - 변수명
100 - 값



문자열 비교(equals)
myNum.equals(lottoNumber)

@Override 어노테이션
- 자바에서 @를 어노테이션이라고 부른다.


------------------------------------------------------------------------
Arrays 클래스						l
Arrays.toString(arr) 배열출력					l
Arrays.sort(arr)  정렬					l
Arrays.sort(arr2,Comparator.reverseOrder()); 내림차순 정렬	l							
------------------------------------------------------------------------

int[] arr = {1,2,3}
여기서 arr은 주소값만 저장

--------------------------------------------------------------------

	   얕은복사
int[] arr01 = { 1, 2, 3 };
int[] arr02 = arr01;

              깊은 복사

-반복문을 이용한 깊은 복사
int[] cards = { 1, 6, 4, 5, 3, 2 };
int[] newCards = new int[cards.length];
for (int i = 0; i < cards.length; i++) {
       newCards[i] = cards[i];
}

-Arrays클래스를 이용한 깊은 복사
int[] newCards2 = Arrays.copyOf(cards, cards.length);

-System클래스를 이용한 깊은 복사
int [] newCards3 = new int[cards.length];
		
System.arraycopy(cards,0,newCards3,0,cards.length);


--------------------------------------------------------------------


랜덤 클래스
Random rnd = new Random();
numbers[i] = rnd.nextInt(30) + 1;


---------------------------------------------------
클래스명 변수명 = new 클래스명();	          ㅣ
- new : 메모리에 객체를 올리기위한 공간할당.  ㅣ
- 클래스명(); : 생성자의 호출		          ㅣ
---------------------------------------------------

클래스 - 실행용 - main()메서드 , 다른 곳에서 사용 안됨X
         - 참조용(설계도) - 객체 생성용,상태와 기능의 정의 다른곳에서 사용 가능O
	(여러개 가능)

클래스 구성요소 - 변수(필드,멤버)
	         - 메서드




---------------------------------------------------------------
생성자			메서드			ㅣ
클래스명			메서드명(임의)		ㅣ
호출(객체 생성시new)	호출(여러번 가능)		ㅣ
반환값(X)			반환값(O,X)		ㅣ
반환형 자체 X		반환형 결정,없으면 void	ㅣ
---------------------------------------------------------------
---------------------------------------------------------------
메서드(함수)					ㅣ
접근제한자  반환형  메서드명(매개변수1, 매개변수2){	ㅣ
	return 반환값;				ㅣ
}						ㅣ
반환형은 반환값이랑 자료형이 같아야됨 반환값없으면 void	 l
---------------------------------------------------------------
접근제한자
- 클래스/메서드/필드/에 대한 접근을 어느범위까지 제한하느냐에 대한 키워드
1. public : 모든 접근을 허용. 같은 프로젝트 내의 모든 객체들이 사용할 수 있도록 허용
2. private : 현재 클래스 내에서만 사용을 허가
3. protected : 상속관계의 객체들에서만 사용을 허가
4. default : 같은 패키지내의 객체에서만 사용을 허가(아무것도 쓰지 않으면 자동으로 (default)

public : 제한 없이 모든 패키지, 모든 클래스에서 접근이 가능하다.
protected : 같은 패키지 안에서 접근 가능,다른 패키지라도 자식클래스라면 접근이 가능하다.
default : 같은 패키지 내에서만 접근이 가능하다.
private : 같은 클래스 내에서만 접근이 가능하다.


default
- 접근제한자를 따로 명시하지 않는다면 클래스와 멤버들은 자동으로 default를 가진다.
default로 선언된 클래스와 멤버들은 같은 패키지 안에서는 어디든지 접근 및 사용이 가능하나
다른 패키지에서는 접근이 불가능하다.

protected
클래스 멤버를 윟나 제한자로, 상속과 관련이 있는 제한자이다.
default처름 같은 패키지 안에서 접근과 사용을 허가하지만, 다른 패키지에서의 접근을
완전히 제한하는것이 아닌, "해당 클래스와 상속관계에 있는 자식 클래스"라면 
다른 패키지라도 접근 및 사용이 가능하다.

private
가장 사용 범위가 좁은 클래스 멤버를 위한 제한자이다.
클래스가 public/default 이더라도, private으로 선언된 멤버들은 클래스 외부에서
접근이 불가능하다.
오직 선언된 클래스 내부에서만 접근하여 사용할 수 있다.


----------생성자명은 무조건 클래스명--------------
접근제한자 클래스명(매개변수1,매개변수2...){	ㅣ
					ㅣ
}					ㅣ
-----------------------------------------------------
생성자를 통해서 필드를 초기화 하면 생성되는 객체마다 값을 다르게 넣어줄 수 있다.




setter - 필드의 값을 세팅
getter - 필드에 세팅된 값을 반환

-----------오버로딩 규칙---------중요 면접 단골 -----------
1. 생성자나 메서드의 이름은 그대로 사용해야 한다.	l
2. 매개변수의 개수가 달라야 한다.			l
3. 매개변수의 개수 같아도 자료형이 달라야 한다.		l
						l
public Phone(String b, int s) {			l
	brand = b;				l
	series = s;				l
}						l
						l
public Phone (String b , int s, String c) {		l
	brand = b;				l
	series = s;				l
	color = c;				l
}						l
--------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------
오버라이딩( @Overriding )(상속에서만 사용)								l
- 부모클래스에서 상속 받은 자식 클래스는 부모 클래스의 필드와 메서드를 가져와서 그대로 사용할 수 있다.		l
- 하지만 필요하다면, 자식 클래스가 상속받은 메서드의 내용을 변경해서 사용할 수 있다.				l
- 우리는 이렇게 상속받은 메서드를 변경해서 다시 구현하는 것을 오버라이딩(Overriding)이라고 한다.		l
요점 - 메서드명,반환형,매개변수 모두 같아야하고 내용만 달라야한다.접근제한자는 부모의메서드보다 좁은범위.        ㅣ
												l
----------------------오버라이딩 규칙-------------------------------------------------------			l
1. 부모클래스의 메서드명, 반환형, 매개변수까지 동일해야 한다.			ㅣ			l
2. 부모클래스의 메서드보다 접근 제한 범위를 넓힐 수있다.				ㅣ			l
----------------------------------------------------------------------------------------------------------------------------

상속------------------------------------------------
부모클래스 -> 상속해주는 클래스		ㅣ
부모의 맴버,메서드를 상속 해준다.		ㅣ
					ㅣ
자식클래스 -> 상속받는 클래스		ㅣ
다시 정의하지 않고 부모의 것을 사용할 수 있다.	ㅣ
class 자식클래스명 extends 부모클래스명{	ㅣ
}					ㅣ
----------------------------------------------------

객체 지향의 특징--------------------------중요 면접에 많이나옴----------------------------
- 캡슐화									ㅣ
객체 내부의 멤버(필드, 메서드 등)를 객체 외부에서 볼 수 없도록 캡슐화 한다.		ㅣ
접근이 필요한 경우 public 메서드를 활용해 접근하고, 이외의 값들은 모두 캡슐화를 통해 ㅣ
정보를 은닉한다.								ㅣ
									ㅣ
- 상속									ㅣ
미리 정의된 부모 클래스의 멤버를 자식 클래스가 물려받는다.			ㅣ
									ㅣ
- 다형성									ㅣ
하나의 방법으로 여러 객체를 호출하여 사용할 수 있다.				ㅣ
									ㅣ
- 추상화									ㅣ
공통괸 기능과 정보를 추출해 객체화 한다.					ㅣ
----------------------------------------------------------------------------------------------


instanceof연산자
A instanceof B : A 객체가 생성될 때 B 타입으로 생성되었는지 확인하는 연산자
맞으면 true, 아이면 false를 반환하며 만약 null을 가리키고 있다면 false를 반환한다.

객체명 instanceof 클래스명

추상메서드
접근제한자 abstract 반환형 메서드명(매개변수);
abstract 접근제한자 반환형 메서드명(매개변수);

추상화, 인터페이스의 장점
1. 정보은닉
2. 수정 최소화




에러(error)
OutOfMemoryError 프로그램 실행중 메모리 부족
IOEError 입출력 에러
StackOverFlowError 가용 메모리 부족 현상, 재귀 호출 문제시 발생

예외(Exception)클래스
ArrayIndexOutOfBoundsException 인덱스번호 오류
InputMismatchException 정수를 입력하지 않았을때
NullPointerException
객체가 제대로 생성되지 않은 상태에서 사용할 경우 발생한다.
객체를 선언하면,주소를 갖게 되고, 그것을 통해 객체에 접근해 값을 가져온다.
객체변수는 정의되었는데 메모리에 올리지 않았을때 예외가 발생한다.

---------------------------------------------------------------------------------------------------------------------

제네릭의 형변환
- 제네릭 형변환
배열과 같은 일반적인 변수 타입과 달리 제네릭 서브 타입간에는 형변환이 불가능하다.
자연스럽게 다형성이 적용될 것이라고 생각할 수 있지만, 실상 제네릭은 전달받은 타입으로만 캐스팅이 가능하다.

제네릭 타입은 상하관계가 없다.
제네릭 타입변수끼리는 아무리 상속관계에 놓인다 한들 형변환이 불가능하다.

제네릭 와일드카드
제네릭 간의 형변환을 성립되게 하기 위해서는 제네릭에서 제공하는 와일드카드 문법을 이용해야 한다.

<?> : Unbounded WildCards(제한없음)
- 타입 파라미터를 대치하는 구체적인 타입으로 모든 클래스나 인터페이스 타입이 올 수 있다.

<? extends 상위타입> : Upper Bounded WildCards(상위 클래스 제한)
- 타입 파라미터를 대치하는 구체적인 타입으로 상위 타입이나, 상위 타입의 하위 타입만 올 수 있다.

<? super 하위타입> : Lower Bounded WildCards(하위 클래스 제한)
- 타입 파라미터를 대치하는 구체적인 타입으로 하위 타입이나, 하위 타입의 상위 타입만 올 수 있다.

1. 제네릭 타입 객체 생성 불가능
2. static 필드, 메서드에 제네릭타입 사용불가능
3. 제네릭 타입 자체로 배열 생성 불가능


제네릭 타입 자체를 파라미터로 받을수 있다.
ArrayList<LinkedList<String>> list = new ArrayList<>();
ArrayList의 요소로 LinkedList객체를 가짐

제네릭 인터페이스
인터페이스에도 제네릭을 붙힐 수 있음
구현한 클래스에서도 제네릭 타입에 맞춰 구현해야한다.

제네릭 메서드
클래스랑 별개로 제네릭 타입매개변수를 갖는 메서드
public <T> T addBox(T x, T y){
}

와일드카드
- 제네릭타입에 들어갈 수 있는 범위를 한정

<?> : Unbounded WildCards(제한없음)
- 타입 파라미터를 대치하는 구체적인 타입으로 모든 클래스나 인터페이스 타입이 올 수 있다.

<? extends 상위타입> : Upper Bounded WildCards(상위 클래스 제한)
- 타입 파라미터를 대치하는 구체적인 타입으로 상위 타입이나, 상위 타입의 하위 타입만 올 수 있다.

<? super 하위타입> : Lower Bounded WildCards(하위 클래스 제한)
- 타입 파라미터를 대치하는 구체적인 타입으로 하위 타입이나, 하위 타입의 상위 타입만 올 수 있다.
---------------------------------------------------------------------------------------------------------------------



public
private
instanceof

